// automatically generated by the FlatBuffers compiler, do not modify
import flatbuffers

namespace ppx

enum MessageBody:
    MessageBody_NONE = 0
    MessageBody_Handshake = 1
    MessageBody_HandshakeResult = 2
    MessageBody_Run = 3
    MessageBody_RunResult = 4
    MessageBody_Sample = 5
    MessageBody_SampleResult = 6
    MessageBody_Observe = 7
    MessageBody_ObserveResult = 8
    MessageBody_Tag = 9
    MessageBody_TagResult = 10
    MessageBody_Reset = 11

enum Distribution:
    Distribution_NONE = 0
    Distribution_Normal = 1
    Distribution_Uniform = 2
    Distribution_Categorical = 3
    Distribution_Poisson = 4

class Message

class Tensor

class Handshake

class HandshakeResult

class Run

class RunResult

class Sample

class SampleResult

class Observe

class ObserveResult

class Tag

class TagResult

class Reset

class Normal

class Uniform

class Categorical

class Poisson

class Message : flatbuffers_handle
    def body_type():
        return MessageBody(buf_.flatbuffers_field_int8(pos_, 4, 0))
    def body_as_Handshake():
        return ppx_Handshake { buf_, buf_.flatbuffers_field_table(pos_, 6) }
    def body_as_HandshakeResult():
        return ppx_HandshakeResult { buf_, buf_.flatbuffers_field_table(pos_, 6) }
    def body_as_Run():
        return ppx_Run { buf_, buf_.flatbuffers_field_table(pos_, 6) }
    def body_as_RunResult():
        return ppx_RunResult { buf_, buf_.flatbuffers_field_table(pos_, 6) }
    def body_as_Sample():
        return ppx_Sample { buf_, buf_.flatbuffers_field_table(pos_, 6) }
    def body_as_SampleResult():
        return ppx_SampleResult { buf_, buf_.flatbuffers_field_table(pos_, 6) }
    def body_as_Observe():
        return ppx_Observe { buf_, buf_.flatbuffers_field_table(pos_, 6) }
    def body_as_ObserveResult():
        return ppx_ObserveResult { buf_, buf_.flatbuffers_field_table(pos_, 6) }
    def body_as_Tag():
        return ppx_Tag { buf_, buf_.flatbuffers_field_table(pos_, 6) }
    def body_as_TagResult():
        return ppx_TagResult { buf_, buf_.flatbuffers_field_table(pos_, 6) }
    def body_as_Reset():
        return ppx_Reset { buf_, buf_.flatbuffers_field_table(pos_, 6) }

def GetRootAsMessage(buf:string): return Message { buf, buf.flatbuffers_indirect(0) }

struct MessageBuilder:
    b_:flatbuffers_builder
    def start():
        b_.StartObject(2)
        return this
    def add_body_type(body_type:MessageBody):
        b_.PrependUint8Slot(0, body_type, 0)
        return this
    def add_body(body:flatbuffers_offset):
        b_.PrependUOffsetTRelativeSlot(1, body)
        return this
    def end():
        return b_.EndObject()

class Tensor : flatbuffers_handle
    def data(i:int):
        return buf_.read_float64_le(buf_.flatbuffers_field_vector(pos_, 4) + i * 8)
    def data_length():
        return buf_.flatbuffers_field_vector_len(pos_, 4)
    def shape(i:int):
        return buf_.read_int32_le(buf_.flatbuffers_field_vector(pos_, 6) + i * 4)
    def shape_length():
        return buf_.flatbuffers_field_vector_len(pos_, 6)

def GetRootAsTensor(buf:string): return Tensor { buf, buf.flatbuffers_indirect(0) }

struct TensorBuilder:
    b_:flatbuffers_builder
    def start():
        b_.StartObject(2)
        return this
    def add_data(data:flatbuffers_offset):
        b_.PrependUOffsetTRelativeSlot(0, data)
        return this
    def add_shape(shape:flatbuffers_offset):
        b_.PrependUOffsetTRelativeSlot(1, shape)
        return this
    def end():
        return b_.EndObject()

def TensorStartDataVector(b_:flatbuffers_builder, n_:int):
    b_.StartVector(8, n_, 8)
def TensorCreateDataVector(b_:flatbuffers_builder, v_:[float]):
    b_.StartVector(8, v_.length, 8)
    reverse(v_) e_: b_.PrependFloat64(e_)
    return b_.EndVector(v_.length)

def TensorStartShapeVector(b_:flatbuffers_builder, n_:int):
    b_.StartVector(4, n_, 4)
def TensorCreateShapeVector(b_:flatbuffers_builder, v_:[int]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependInt32(e_)
    return b_.EndVector(v_.length)

class Handshake : flatbuffers_handle
    def system_name():
        return buf_.flatbuffers_field_string(pos_, 4)

def GetRootAsHandshake(buf:string): return Handshake { buf, buf.flatbuffers_indirect(0) }

struct HandshakeBuilder:
    b_:flatbuffers_builder
    def start():
        b_.StartObject(1)
        return this
    def add_system_name(system_name:flatbuffers_offset):
        b_.PrependUOffsetTRelativeSlot(0, system_name)
        return this
    def end():
        return b_.EndObject()

class HandshakeResult : flatbuffers_handle
    def system_name():
        return buf_.flatbuffers_field_string(pos_, 4)
    def model_name():
        return buf_.flatbuffers_field_string(pos_, 6)

def GetRootAsHandshakeResult(buf:string): return HandshakeResult { buf, buf.flatbuffers_indirect(0) }

struct HandshakeResultBuilder:
    b_:flatbuffers_builder
    def start():
        b_.StartObject(2)
        return this
    def add_system_name(system_name:flatbuffers_offset):
        b_.PrependUOffsetTRelativeSlot(0, system_name)
        return this
    def add_model_name(model_name:flatbuffers_offset):
        b_.PrependUOffsetTRelativeSlot(1, model_name)
        return this
    def end():
        return b_.EndObject()

class Run : flatbuffers_handle

def GetRootAsRun(buf:string): return Run { buf, buf.flatbuffers_indirect(0) }

struct RunBuilder:
    b_:flatbuffers_builder
    def start():
        b_.StartObject(0)
        return this
    def end():
        return b_.EndObject()

class RunResult : flatbuffers_handle
    def result():
        let o = buf_.flatbuffers_field_table(pos_, 4)
        return if o: ppx_Tensor { buf_, o } else: nil

def GetRootAsRunResult(buf:string): return RunResult { buf, buf.flatbuffers_indirect(0) }

struct RunResultBuilder:
    b_:flatbuffers_builder
    def start():
        b_.StartObject(1)
        return this
    def add_result(result:flatbuffers_offset):
        b_.PrependUOffsetTRelativeSlot(0, result)
        return this
    def end():
        return b_.EndObject()

class Sample : flatbuffers_handle
    def address():
        return buf_.flatbuffers_field_string(pos_, 4)
    def name():
        return buf_.flatbuffers_field_string(pos_, 6)
    def distribution_type():
        return Distribution(buf_.flatbuffers_field_int8(pos_, 8, 0))
    def distribution_as_Normal():
        return ppx_Normal { buf_, buf_.flatbuffers_field_table(pos_, 10) }
    def distribution_as_Uniform():
        return ppx_Uniform { buf_, buf_.flatbuffers_field_table(pos_, 10) }
    def distribution_as_Categorical():
        return ppx_Categorical { buf_, buf_.flatbuffers_field_table(pos_, 10) }
    def distribution_as_Poisson():
        return ppx_Poisson { buf_, buf_.flatbuffers_field_table(pos_, 10) }
    def control():
        return buf_.flatbuffers_field_int8(pos_, 12, 1)
    def replace():
        return buf_.flatbuffers_field_int8(pos_, 14, 0)

def GetRootAsSample(buf:string): return Sample { buf, buf.flatbuffers_indirect(0) }

struct SampleBuilder:
    b_:flatbuffers_builder
    def start():
        b_.StartObject(6)
        return this
    def add_address(address:flatbuffers_offset):
        b_.PrependUOffsetTRelativeSlot(0, address)
        return this
    def add_name(name:flatbuffers_offset):
        b_.PrependUOffsetTRelativeSlot(1, name)
        return this
    def add_distribution_type(distribution_type:Distribution):
        b_.PrependUint8Slot(2, distribution_type, 0)
        return this
    def add_distribution(distribution:flatbuffers_offset):
        b_.PrependUOffsetTRelativeSlot(3, distribution)
        return this
    def add_control(control:int):
        b_.PrependBoolSlot(4, control, 1)
        return this
    def add_replace(replace:int):
        b_.PrependBoolSlot(5, replace, 0)
        return this
    def end():
        return b_.EndObject()

class SampleResult : flatbuffers_handle
    def result():
        let o = buf_.flatbuffers_field_table(pos_, 4)
        return if o: ppx_Tensor { buf_, o } else: nil

def GetRootAsSampleResult(buf:string): return SampleResult { buf, buf.flatbuffers_indirect(0) }

struct SampleResultBuilder:
    b_:flatbuffers_builder
    def start():
        b_.StartObject(1)
        return this
    def add_result(result:flatbuffers_offset):
        b_.PrependUOffsetTRelativeSlot(0, result)
        return this
    def end():
        return b_.EndObject()

class Observe : flatbuffers_handle
    def address():
        return buf_.flatbuffers_field_string(pos_, 4)
    def name():
        return buf_.flatbuffers_field_string(pos_, 6)
    def distribution_type():
        return Distribution(buf_.flatbuffers_field_int8(pos_, 8, 0))
    def distribution_as_Normal():
        return ppx_Normal { buf_, buf_.flatbuffers_field_table(pos_, 10) }
    def distribution_as_Uniform():
        return ppx_Uniform { buf_, buf_.flatbuffers_field_table(pos_, 10) }
    def distribution_as_Categorical():
        return ppx_Categorical { buf_, buf_.flatbuffers_field_table(pos_, 10) }
    def distribution_as_Poisson():
        return ppx_Poisson { buf_, buf_.flatbuffers_field_table(pos_, 10) }
    def value():
        let o = buf_.flatbuffers_field_table(pos_, 12)
        return if o: ppx_Tensor { buf_, o } else: nil

def GetRootAsObserve(buf:string): return Observe { buf, buf.flatbuffers_indirect(0) }

struct ObserveBuilder:
    b_:flatbuffers_builder
    def start():
        b_.StartObject(5)
        return this
    def add_address(address:flatbuffers_offset):
        b_.PrependUOffsetTRelativeSlot(0, address)
        return this
    def add_name(name:flatbuffers_offset):
        b_.PrependUOffsetTRelativeSlot(1, name)
        return this
    def add_distribution_type(distribution_type:Distribution):
        b_.PrependUint8Slot(2, distribution_type, 0)
        return this
    def add_distribution(distribution:flatbuffers_offset):
        b_.PrependUOffsetTRelativeSlot(3, distribution)
        return this
    def add_value(value:flatbuffers_offset):
        b_.PrependUOffsetTRelativeSlot(4, value)
        return this
    def end():
        return b_.EndObject()

class ObserveResult : flatbuffers_handle

def GetRootAsObserveResult(buf:string): return ObserveResult { buf, buf.flatbuffers_indirect(0) }

struct ObserveResultBuilder:
    b_:flatbuffers_builder
    def start():
        b_.StartObject(0)
        return this
    def end():
        return b_.EndObject()

class Tag : flatbuffers_handle
    def address():
        return buf_.flatbuffers_field_string(pos_, 4)
    def name():
        return buf_.flatbuffers_field_string(pos_, 6)
    def value():
        let o = buf_.flatbuffers_field_table(pos_, 8)
        return if o: ppx_Tensor { buf_, o } else: nil

def GetRootAsTag(buf:string): return Tag { buf, buf.flatbuffers_indirect(0) }

struct TagBuilder:
    b_:flatbuffers_builder
    def start():
        b_.StartObject(3)
        return this
    def add_address(address:flatbuffers_offset):
        b_.PrependUOffsetTRelativeSlot(0, address)
        return this
    def add_name(name:flatbuffers_offset):
        b_.PrependUOffsetTRelativeSlot(1, name)
        return this
    def add_value(value:flatbuffers_offset):
        b_.PrependUOffsetTRelativeSlot(2, value)
        return this
    def end():
        return b_.EndObject()

class TagResult : flatbuffers_handle

def GetRootAsTagResult(buf:string): return TagResult { buf, buf.flatbuffers_indirect(0) }

struct TagResultBuilder:
    b_:flatbuffers_builder
    def start():
        b_.StartObject(0)
        return this
    def end():
        return b_.EndObject()

class Reset : flatbuffers_handle

def GetRootAsReset(buf:string): return Reset { buf, buf.flatbuffers_indirect(0) }

struct ResetBuilder:
    b_:flatbuffers_builder
    def start():
        b_.StartObject(0)
        return this
    def end():
        return b_.EndObject()

class Normal : flatbuffers_handle
    def mean():
        let o = buf_.flatbuffers_field_table(pos_, 4)
        return if o: ppx_Tensor { buf_, o } else: nil
    def stddev():
        let o = buf_.flatbuffers_field_table(pos_, 6)
        return if o: ppx_Tensor { buf_, o } else: nil

def GetRootAsNormal(buf:string): return Normal { buf, buf.flatbuffers_indirect(0) }

struct NormalBuilder:
    b_:flatbuffers_builder
    def start():
        b_.StartObject(2)
        return this
    def add_mean(mean:flatbuffers_offset):
        b_.PrependUOffsetTRelativeSlot(0, mean)
        return this
    def add_stddev(stddev:flatbuffers_offset):
        b_.PrependUOffsetTRelativeSlot(1, stddev)
        return this
    def end():
        return b_.EndObject()

class Uniform : flatbuffers_handle
    def low():
        let o = buf_.flatbuffers_field_table(pos_, 4)
        return if o: ppx_Tensor { buf_, o } else: nil
    def high():
        let o = buf_.flatbuffers_field_table(pos_, 6)
        return if o: ppx_Tensor { buf_, o } else: nil

def GetRootAsUniform(buf:string): return Uniform { buf, buf.flatbuffers_indirect(0) }

struct UniformBuilder:
    b_:flatbuffers_builder
    def start():
        b_.StartObject(2)
        return this
    def add_low(low:flatbuffers_offset):
        b_.PrependUOffsetTRelativeSlot(0, low)
        return this
    def add_high(high:flatbuffers_offset):
        b_.PrependUOffsetTRelativeSlot(1, high)
        return this
    def end():
        return b_.EndObject()

class Categorical : flatbuffers_handle
    def probs():
        let o = buf_.flatbuffers_field_table(pos_, 4)
        return if o: ppx_Tensor { buf_, o } else: nil

def GetRootAsCategorical(buf:string): return Categorical { buf, buf.flatbuffers_indirect(0) }

struct CategoricalBuilder:
    b_:flatbuffers_builder
    def start():
        b_.StartObject(1)
        return this
    def add_probs(probs:flatbuffers_offset):
        b_.PrependUOffsetTRelativeSlot(0, probs)
        return this
    def end():
        return b_.EndObject()

class Poisson : flatbuffers_handle
    def rate():
        let o = buf_.flatbuffers_field_table(pos_, 4)
        return if o: ppx_Tensor { buf_, o } else: nil

def GetRootAsPoisson(buf:string): return Poisson { buf, buf.flatbuffers_indirect(0) }

struct PoissonBuilder:
    b_:flatbuffers_builder
    def start():
        b_.StartObject(1)
        return this
    def add_rate(rate:flatbuffers_offset):
        b_.PrependUOffsetTRelativeSlot(0, rate)
        return this
    def end():
        return b_.EndObject()

