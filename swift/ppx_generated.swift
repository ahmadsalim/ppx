// automatically generated by the FlatBuffers compiler, do not modify

import FlatBuffers

public enum ppx {

public enum MessageBody: UInt8, Enum { 
	public typealias T = UInt8
	public static var byteSize: Int { return MemoryLayout<UInt8>.size }
	public var value: UInt8 { return self.rawValue }
	case none = 0
	case handshake = 1
	case handshakeresult = 2
	case run = 3
	case runresult = 4
	case sample = 5
	case sampleresult = 6
	case observe = 7
	case observeresult = 8
	case tag = 9
	case tagresult = 10
	case reset = 11


	public static var max: MessageBody { return .reset }
	public static var min: MessageBody { return .none }
}

public enum Distribution: UInt8, Enum { 
	public typealias T = UInt8
	public static var byteSize: Int { return MemoryLayout<UInt8>.size }
	public var value: UInt8 { return self.rawValue }
	case none = 0
	case normal = 1
	case uniform = 2
	case categorical = 3
	case poisson = 4
	case bernoulli = 5
	case beta = 6
	case exponential = 7
	case gamma = 8
	case lognormal = 9


	public static var max: Distribution { return .lognormal }
	public static var min: Distribution { return .none }
}

public struct Message: FlatBufferObject {

	static func validateVersion() { FlatBuffersVersion_1_12_0() }
	public var __buffer: ByteBuffer! { return _accessor.bb }

	private var _accessor: Table
	public static func finish(_ fbb: FlatBufferBuilder, end: Offset<UOffset>, prefix: Bool = false) { fbb.finish(offset: end, fileId: "PPXF", addPrefix: prefix) }
	public static func getRootAsMessage(bb: ByteBuffer) -> Message { return Message(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public var bodyType: ppx.MessageBody { let o = _accessor.offset(4); return o == 0 ? .none : ppx.MessageBody(rawValue: _accessor.readBuffer(of: UInt8.self, at: o)) ?? .none }
	public func body<T: FlatBufferObject>(type: T.Type) -> T? { let o = _accessor.offset(6); return o == 0 ? nil : _accessor.union(o) }
	public static func startMessage(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
	public static func add(bodyType: ppx.MessageBody, _ fbb: FlatBufferBuilder) { fbb.add(element: bodyType.rawValue, def: 0, at: 0) }
	public static func add(body: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: body, at: 1)  }
	public static func endMessage(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
	public static func createMessage(_ fbb: FlatBufferBuilder,
		bodyType: ppx.MessageBody = .none,
		offsetOfBody body: Offset<UOffset> = Offset()) -> Offset<UOffset> {
		let __start = Message.startMessage(fbb)
		Message.add(bodyType: bodyType, fbb)
		Message.add(body: body, fbb)
		return Message.endMessage(fbb, start: __start)
	}
}

public struct Tensor: FlatBufferObject {

	static func validateVersion() { FlatBuffersVersion_1_12_0() }
	public var __buffer: ByteBuffer! { return _accessor.bb }

	private var _accessor: Table
	public static func finish(_ fbb: FlatBufferBuilder, end: Offset<UOffset>, prefix: Bool = false) { fbb.finish(offset: end, fileId: "PPXF", addPrefix: prefix) }
	public static func getRootAsTensor(bb: ByteBuffer) -> Tensor { return Tensor(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public var dataCount: Int32 { let o = _accessor.offset(4); return o == 0 ? 0 : _accessor.vector(count: o) }
	public func data(at index: Int32) -> Double { let o = _accessor.offset(4); return o == 0 ? 0 : _accessor.directRead(of: Double.self, offset: _accessor.vector(at: o) + index * 8) }
	public var data: [Double] { return _accessor.getVector(at: 4) ?? [] }
	public var shapeCount: Int32 { let o = _accessor.offset(6); return o == 0 ? 0 : _accessor.vector(count: o) }
	public func shape(at index: Int32) -> Int32 { let o = _accessor.offset(6); return o == 0 ? 0 : _accessor.directRead(of: Int32.self, offset: _accessor.vector(at: o) + index * 4) }
	public var shape: [Int32] { return _accessor.getVector(at: 6) ?? [] }
	public static func startTensor(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
	public static func addVectorOf(data: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: data, at: 0)  }
	public static func addVectorOf(shape: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: shape, at: 1)  }
	public static func endTensor(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
	public static func createTensor(_ fbb: FlatBufferBuilder,
		vectorOfData data: Offset<UOffset> = Offset(),
		vectorOfShape shape: Offset<UOffset> = Offset()) -> Offset<UOffset> {
		let __start = Tensor.startTensor(fbb)
		Tensor.addVectorOf(data: data, fbb)
		Tensor.addVectorOf(shape: shape, fbb)
		return Tensor.endTensor(fbb, start: __start)
	}
}

public struct Handshake: FlatBufferObject {

	static func validateVersion() { FlatBuffersVersion_1_12_0() }
	public var __buffer: ByteBuffer! { return _accessor.bb }

	private var _accessor: Table
	public static func finish(_ fbb: FlatBufferBuilder, end: Offset<UOffset>, prefix: Bool = false) { fbb.finish(offset: end, fileId: "PPXF", addPrefix: prefix) }
	public static func getRootAsHandshake(bb: ByteBuffer) -> Handshake { return Handshake(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public var systemName: String? { let o = _accessor.offset(4); return o == 0 ? nil : _accessor.string(at: o) }
	public var systemNameSegmentArray: [UInt8]? { return _accessor.getVector(at: 4) }
	public static func startHandshake(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
	public static func add(systemName: Offset<String>, _ fbb: FlatBufferBuilder) { fbb.add(offset: systemName, at: 0)  }
	public static func endHandshake(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
	public static func createHandshake(_ fbb: FlatBufferBuilder,
		offsetOfSystemName systemName: Offset<String> = Offset()) -> Offset<UOffset> {
		let __start = Handshake.startHandshake(fbb)
		Handshake.add(systemName: systemName, fbb)
		return Handshake.endHandshake(fbb, start: __start)
	}
}

public struct HandshakeResult: FlatBufferObject {

	static func validateVersion() { FlatBuffersVersion_1_12_0() }
	public var __buffer: ByteBuffer! { return _accessor.bb }

	private var _accessor: Table
	public static func finish(_ fbb: FlatBufferBuilder, end: Offset<UOffset>, prefix: Bool = false) { fbb.finish(offset: end, fileId: "PPXF", addPrefix: prefix) }
	public static func getRootAsHandshakeResult(bb: ByteBuffer) -> HandshakeResult { return HandshakeResult(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public var systemName: String? { let o = _accessor.offset(4); return o == 0 ? nil : _accessor.string(at: o) }
	public var systemNameSegmentArray: [UInt8]? { return _accessor.getVector(at: 4) }
	public var modelName: String? { let o = _accessor.offset(6); return o == 0 ? nil : _accessor.string(at: o) }
	public var modelNameSegmentArray: [UInt8]? { return _accessor.getVector(at: 6) }
	public static func startHandshakeResult(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
	public static func add(systemName: Offset<String>, _ fbb: FlatBufferBuilder) { fbb.add(offset: systemName, at: 0)  }
	public static func add(modelName: Offset<String>, _ fbb: FlatBufferBuilder) { fbb.add(offset: modelName, at: 1)  }
	public static func endHandshakeResult(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
	public static func createHandshakeResult(_ fbb: FlatBufferBuilder,
		offsetOfSystemName systemName: Offset<String> = Offset(),
		offsetOfModelName modelName: Offset<String> = Offset()) -> Offset<UOffset> {
		let __start = HandshakeResult.startHandshakeResult(fbb)
		HandshakeResult.add(systemName: systemName, fbb)
		HandshakeResult.add(modelName: modelName, fbb)
		return HandshakeResult.endHandshakeResult(fbb, start: __start)
	}
}

public struct Run: FlatBufferObject {

	static func validateVersion() { FlatBuffersVersion_1_12_0() }
	public var __buffer: ByteBuffer! { return _accessor.bb }

	private var _accessor: Table
	public static func finish(_ fbb: FlatBufferBuilder, end: Offset<UOffset>, prefix: Bool = false) { fbb.finish(offset: end, fileId: "PPXF", addPrefix: prefix) }
	public static func getRootAsRun(bb: ByteBuffer) -> Run { return Run(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public static func startRun(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
	public static func endRun(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
	public static func createRun(_ fbb: FlatBufferBuilder) -> Offset<UOffset> {
		let __start = Run.startRun(fbb)
		return Run.endRun(fbb, start: __start)
	}
}

public struct RunResult: FlatBufferObject {

	static func validateVersion() { FlatBuffersVersion_1_12_0() }
	public var __buffer: ByteBuffer! { return _accessor.bb }

	private var _accessor: Table
	public static func finish(_ fbb: FlatBufferBuilder, end: Offset<UOffset>, prefix: Bool = false) { fbb.finish(offset: end, fileId: "PPXF", addPrefix: prefix) }
	public static func getRootAsRunResult(bb: ByteBuffer) -> RunResult { return RunResult(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public var result: ppx.Tensor? { let o = _accessor.offset(4); return o == 0 ? nil : ppx.Tensor(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
	public static func startRunResult(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
	public static func add(result: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: result, at: 0)  }
	public static func endRunResult(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
	public static func createRunResult(_ fbb: FlatBufferBuilder,
		offsetOfResult result: Offset<UOffset> = Offset()) -> Offset<UOffset> {
		let __start = RunResult.startRunResult(fbb)
		RunResult.add(result: result, fbb)
		return RunResult.endRunResult(fbb, start: __start)
	}
}

public struct Sample: FlatBufferObject {

	static func validateVersion() { FlatBuffersVersion_1_12_0() }
	public var __buffer: ByteBuffer! { return _accessor.bb }

	private var _accessor: Table
	public static func finish(_ fbb: FlatBufferBuilder, end: Offset<UOffset>, prefix: Bool = false) { fbb.finish(offset: end, fileId: "PPXF", addPrefix: prefix) }
	public static func getRootAsSample(bb: ByteBuffer) -> Sample { return Sample(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public var address: String? { let o = _accessor.offset(4); return o == 0 ? nil : _accessor.string(at: o) }
	public var addressSegmentArray: [UInt8]? { return _accessor.getVector(at: 4) }
	public var name: String? { let o = _accessor.offset(6); return o == 0 ? nil : _accessor.string(at: o) }
	public var nameSegmentArray: [UInt8]? { return _accessor.getVector(at: 6) }
	public var distributionType: ppx.Distribution { let o = _accessor.offset(8); return o == 0 ? .none : ppx.Distribution(rawValue: _accessor.readBuffer(of: UInt8.self, at: o)) ?? .none }
	public func distribution<T: FlatBufferObject>(type: T.Type) -> T? { let o = _accessor.offset(10); return o == 0 ? nil : _accessor.union(o) }
	public var control: Bool { let o = _accessor.offset(12); return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o) }
	public var replace: Bool { let o = _accessor.offset(14); return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o) }
	public static func startSample(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 6) }
	public static func add(address: Offset<String>, _ fbb: FlatBufferBuilder) { fbb.add(offset: address, at: 0)  }
	public static func add(name: Offset<String>, _ fbb: FlatBufferBuilder) { fbb.add(offset: name, at: 1)  }
	public static func add(distributionType: ppx.Distribution, _ fbb: FlatBufferBuilder) { fbb.add(element: distributionType.rawValue, def: 0, at: 2) }
	public static func add(distribution: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: distribution, at: 3)  }
	public static func add(control: Bool, _ fbb: FlatBufferBuilder) { fbb.add(condition: control, def: true, at: 4) }
	public static func add(replace: Bool, _ fbb: FlatBufferBuilder) { fbb.add(condition: replace, def: false, at: 5) }
	public static func endSample(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
	public static func createSample(_ fbb: FlatBufferBuilder,
		offsetOfAddress address: Offset<String> = Offset(),
		offsetOfName name: Offset<String> = Offset(),
		distributionType: ppx.Distribution = .none,
		offsetOfDistribution distribution: Offset<UOffset> = Offset(),
		control: Bool = true,
		replace: Bool = false) -> Offset<UOffset> {
		let __start = Sample.startSample(fbb)
		Sample.add(address: address, fbb)
		Sample.add(name: name, fbb)
		Sample.add(distributionType: distributionType, fbb)
		Sample.add(distribution: distribution, fbb)
		Sample.add(control: control, fbb)
		Sample.add(replace: replace, fbb)
		return Sample.endSample(fbb, start: __start)
	}
}

public struct SampleResult: FlatBufferObject {

	static func validateVersion() { FlatBuffersVersion_1_12_0() }
	public var __buffer: ByteBuffer! { return _accessor.bb }

	private var _accessor: Table
	public static func finish(_ fbb: FlatBufferBuilder, end: Offset<UOffset>, prefix: Bool = false) { fbb.finish(offset: end, fileId: "PPXF", addPrefix: prefix) }
	public static func getRootAsSampleResult(bb: ByteBuffer) -> SampleResult { return SampleResult(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public var result: ppx.Tensor? { let o = _accessor.offset(4); return o == 0 ? nil : ppx.Tensor(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
	public static func startSampleResult(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
	public static func add(result: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: result, at: 0)  }
	public static func endSampleResult(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
	public static func createSampleResult(_ fbb: FlatBufferBuilder,
		offsetOfResult result: Offset<UOffset> = Offset()) -> Offset<UOffset> {
		let __start = SampleResult.startSampleResult(fbb)
		SampleResult.add(result: result, fbb)
		return SampleResult.endSampleResult(fbb, start: __start)
	}
}

public struct Observe: FlatBufferObject {

	static func validateVersion() { FlatBuffersVersion_1_12_0() }
	public var __buffer: ByteBuffer! { return _accessor.bb }

	private var _accessor: Table
	public static func finish(_ fbb: FlatBufferBuilder, end: Offset<UOffset>, prefix: Bool = false) { fbb.finish(offset: end, fileId: "PPXF", addPrefix: prefix) }
	public static func getRootAsObserve(bb: ByteBuffer) -> Observe { return Observe(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public var address: String? { let o = _accessor.offset(4); return o == 0 ? nil : _accessor.string(at: o) }
	public var addressSegmentArray: [UInt8]? { return _accessor.getVector(at: 4) }
	public var name: String? { let o = _accessor.offset(6); return o == 0 ? nil : _accessor.string(at: o) }
	public var nameSegmentArray: [UInt8]? { return _accessor.getVector(at: 6) }
	public var distributionType: ppx.Distribution { let o = _accessor.offset(8); return o == 0 ? .none : ppx.Distribution(rawValue: _accessor.readBuffer(of: UInt8.self, at: o)) ?? .none }
	public func distribution<T: FlatBufferObject>(type: T.Type) -> T? { let o = _accessor.offset(10); return o == 0 ? nil : _accessor.union(o) }
	public var value: ppx.Tensor? { let o = _accessor.offset(12); return o == 0 ? nil : ppx.Tensor(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
	public static func startObserve(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 5) }
	public static func add(address: Offset<String>, _ fbb: FlatBufferBuilder) { fbb.add(offset: address, at: 0)  }
	public static func add(name: Offset<String>, _ fbb: FlatBufferBuilder) { fbb.add(offset: name, at: 1)  }
	public static func add(distributionType: ppx.Distribution, _ fbb: FlatBufferBuilder) { fbb.add(element: distributionType.rawValue, def: 0, at: 2) }
	public static func add(distribution: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: distribution, at: 3)  }
	public static func add(value: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: value, at: 4)  }
	public static func endObserve(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
	public static func createObserve(_ fbb: FlatBufferBuilder,
		offsetOfAddress address: Offset<String> = Offset(),
		offsetOfName name: Offset<String> = Offset(),
		distributionType: ppx.Distribution = .none,
		offsetOfDistribution distribution: Offset<UOffset> = Offset(),
		offsetOfValue value: Offset<UOffset> = Offset()) -> Offset<UOffset> {
		let __start = Observe.startObserve(fbb)
		Observe.add(address: address, fbb)
		Observe.add(name: name, fbb)
		Observe.add(distributionType: distributionType, fbb)
		Observe.add(distribution: distribution, fbb)
		Observe.add(value: value, fbb)
		return Observe.endObserve(fbb, start: __start)
	}
}

public struct ObserveResult: FlatBufferObject {

	static func validateVersion() { FlatBuffersVersion_1_12_0() }
	public var __buffer: ByteBuffer! { return _accessor.bb }

	private var _accessor: Table
	public static func finish(_ fbb: FlatBufferBuilder, end: Offset<UOffset>, prefix: Bool = false) { fbb.finish(offset: end, fileId: "PPXF", addPrefix: prefix) }
	public static func getRootAsObserveResult(bb: ByteBuffer) -> ObserveResult { return ObserveResult(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public static func startObserveResult(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
	public static func endObserveResult(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
	public static func createObserveResult(_ fbb: FlatBufferBuilder) -> Offset<UOffset> {
		let __start = ObserveResult.startObserveResult(fbb)
		return ObserveResult.endObserveResult(fbb, start: __start)
	}
}

public struct Tag: FlatBufferObject {

	static func validateVersion() { FlatBuffersVersion_1_12_0() }
	public var __buffer: ByteBuffer! { return _accessor.bb }

	private var _accessor: Table
	public static func finish(_ fbb: FlatBufferBuilder, end: Offset<UOffset>, prefix: Bool = false) { fbb.finish(offset: end, fileId: "PPXF", addPrefix: prefix) }
	public static func getRootAsTag(bb: ByteBuffer) -> Tag { return Tag(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public var address: String? { let o = _accessor.offset(4); return o == 0 ? nil : _accessor.string(at: o) }
	public var addressSegmentArray: [UInt8]? { return _accessor.getVector(at: 4) }
	public var name: String? { let o = _accessor.offset(6); return o == 0 ? nil : _accessor.string(at: o) }
	public var nameSegmentArray: [UInt8]? { return _accessor.getVector(at: 6) }
	public var value: ppx.Tensor? { let o = _accessor.offset(8); return o == 0 ? nil : ppx.Tensor(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
	public static func startTag(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
	public static func add(address: Offset<String>, _ fbb: FlatBufferBuilder) { fbb.add(offset: address, at: 0)  }
	public static func add(name: Offset<String>, _ fbb: FlatBufferBuilder) { fbb.add(offset: name, at: 1)  }
	public static func add(value: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: value, at: 2)  }
	public static func endTag(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
	public static func createTag(_ fbb: FlatBufferBuilder,
		offsetOfAddress address: Offset<String> = Offset(),
		offsetOfName name: Offset<String> = Offset(),
		offsetOfValue value: Offset<UOffset> = Offset()) -> Offset<UOffset> {
		let __start = Tag.startTag(fbb)
		Tag.add(address: address, fbb)
		Tag.add(name: name, fbb)
		Tag.add(value: value, fbb)
		return Tag.endTag(fbb, start: __start)
	}
}

public struct TagResult: FlatBufferObject {

	static func validateVersion() { FlatBuffersVersion_1_12_0() }
	public var __buffer: ByteBuffer! { return _accessor.bb }

	private var _accessor: Table
	public static func finish(_ fbb: FlatBufferBuilder, end: Offset<UOffset>, prefix: Bool = false) { fbb.finish(offset: end, fileId: "PPXF", addPrefix: prefix) }
	public static func getRootAsTagResult(bb: ByteBuffer) -> TagResult { return TagResult(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public static func startTagResult(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
	public static func endTagResult(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
	public static func createTagResult(_ fbb: FlatBufferBuilder) -> Offset<UOffset> {
		let __start = TagResult.startTagResult(fbb)
		return TagResult.endTagResult(fbb, start: __start)
	}
}

public struct Reset: FlatBufferObject {

	static func validateVersion() { FlatBuffersVersion_1_12_0() }
	public var __buffer: ByteBuffer! { return _accessor.bb }

	private var _accessor: Table
	public static func finish(_ fbb: FlatBufferBuilder, end: Offset<UOffset>, prefix: Bool = false) { fbb.finish(offset: end, fileId: "PPXF", addPrefix: prefix) }
	public static func getRootAsReset(bb: ByteBuffer) -> Reset { return Reset(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public static func startReset(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
	public static func endReset(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
	public static func createReset(_ fbb: FlatBufferBuilder) -> Offset<UOffset> {
		let __start = Reset.startReset(fbb)
		return Reset.endReset(fbb, start: __start)
	}
}

public struct Normal: FlatBufferObject {

	static func validateVersion() { FlatBuffersVersion_1_12_0() }
	public var __buffer: ByteBuffer! { return _accessor.bb }

	private var _accessor: Table
	public static func finish(_ fbb: FlatBufferBuilder, end: Offset<UOffset>, prefix: Bool = false) { fbb.finish(offset: end, fileId: "PPXF", addPrefix: prefix) }
	public static func getRootAsNormal(bb: ByteBuffer) -> Normal { return Normal(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public var mean: ppx.Tensor? { let o = _accessor.offset(4); return o == 0 ? nil : ppx.Tensor(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
	public var stddev: ppx.Tensor? { let o = _accessor.offset(6); return o == 0 ? nil : ppx.Tensor(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
	public static func startNormal(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
	public static func add(mean: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: mean, at: 0)  }
	public static func add(stddev: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: stddev, at: 1)  }
	public static func endNormal(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
	public static func createNormal(_ fbb: FlatBufferBuilder,
		offsetOfMean mean: Offset<UOffset> = Offset(),
		offsetOfStddev stddev: Offset<UOffset> = Offset()) -> Offset<UOffset> {
		let __start = Normal.startNormal(fbb)
		Normal.add(mean: mean, fbb)
		Normal.add(stddev: stddev, fbb)
		return Normal.endNormal(fbb, start: __start)
	}
}

public struct Uniform: FlatBufferObject {

	static func validateVersion() { FlatBuffersVersion_1_12_0() }
	public var __buffer: ByteBuffer! { return _accessor.bb }

	private var _accessor: Table
	public static func finish(_ fbb: FlatBufferBuilder, end: Offset<UOffset>, prefix: Bool = false) { fbb.finish(offset: end, fileId: "PPXF", addPrefix: prefix) }
	public static func getRootAsUniform(bb: ByteBuffer) -> Uniform { return Uniform(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public var low: ppx.Tensor? { let o = _accessor.offset(4); return o == 0 ? nil : ppx.Tensor(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
	public var high: ppx.Tensor? { let o = _accessor.offset(6); return o == 0 ? nil : ppx.Tensor(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
	public static func startUniform(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
	public static func add(low: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: low, at: 0)  }
	public static func add(high: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: high, at: 1)  }
	public static func endUniform(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
	public static func createUniform(_ fbb: FlatBufferBuilder,
		offsetOfLow low: Offset<UOffset> = Offset(),
		offsetOfHigh high: Offset<UOffset> = Offset()) -> Offset<UOffset> {
		let __start = Uniform.startUniform(fbb)
		Uniform.add(low: low, fbb)
		Uniform.add(high: high, fbb)
		return Uniform.endUniform(fbb, start: __start)
	}
}

public struct Categorical: FlatBufferObject {

	static func validateVersion() { FlatBuffersVersion_1_12_0() }
	public var __buffer: ByteBuffer! { return _accessor.bb }

	private var _accessor: Table
	public static func finish(_ fbb: FlatBufferBuilder, end: Offset<UOffset>, prefix: Bool = false) { fbb.finish(offset: end, fileId: "PPXF", addPrefix: prefix) }
	public static func getRootAsCategorical(bb: ByteBuffer) -> Categorical { return Categorical(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public var probs: ppx.Tensor? { let o = _accessor.offset(4); return o == 0 ? nil : ppx.Tensor(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
	public static func startCategorical(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
	public static func add(probs: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: probs, at: 0)  }
	public static func endCategorical(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
	public static func createCategorical(_ fbb: FlatBufferBuilder,
		offsetOfProbs probs: Offset<UOffset> = Offset()) -> Offset<UOffset> {
		let __start = Categorical.startCategorical(fbb)
		Categorical.add(probs: probs, fbb)
		return Categorical.endCategorical(fbb, start: __start)
	}
}

public struct Poisson: FlatBufferObject {

	static func validateVersion() { FlatBuffersVersion_1_12_0() }
	public var __buffer: ByteBuffer! { return _accessor.bb }

	private var _accessor: Table
	public static func finish(_ fbb: FlatBufferBuilder, end: Offset<UOffset>, prefix: Bool = false) { fbb.finish(offset: end, fileId: "PPXF", addPrefix: prefix) }
	public static func getRootAsPoisson(bb: ByteBuffer) -> Poisson { return Poisson(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public var rate: ppx.Tensor? { let o = _accessor.offset(4); return o == 0 ? nil : ppx.Tensor(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
	public static func startPoisson(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
	public static func add(rate: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: rate, at: 0)  }
	public static func endPoisson(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
	public static func createPoisson(_ fbb: FlatBufferBuilder,
		offsetOfRate rate: Offset<UOffset> = Offset()) -> Offset<UOffset> {
		let __start = Poisson.startPoisson(fbb)
		Poisson.add(rate: rate, fbb)
		return Poisson.endPoisson(fbb, start: __start)
	}
}

public struct Bernoulli: FlatBufferObject {

	static func validateVersion() { FlatBuffersVersion_1_12_0() }
	public var __buffer: ByteBuffer! { return _accessor.bb }

	private var _accessor: Table
	public static func finish(_ fbb: FlatBufferBuilder, end: Offset<UOffset>, prefix: Bool = false) { fbb.finish(offset: end, fileId: "PPXF", addPrefix: prefix) }
	public static func getRootAsBernoulli(bb: ByteBuffer) -> Bernoulli { return Bernoulli(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public var probs: ppx.Tensor? { let o = _accessor.offset(4); return o == 0 ? nil : ppx.Tensor(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
	public static func startBernoulli(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
	public static func add(probs: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: probs, at: 0)  }
	public static func endBernoulli(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
	public static func createBernoulli(_ fbb: FlatBufferBuilder,
		offsetOfProbs probs: Offset<UOffset> = Offset()) -> Offset<UOffset> {
		let __start = Bernoulli.startBernoulli(fbb)
		Bernoulli.add(probs: probs, fbb)
		return Bernoulli.endBernoulli(fbb, start: __start)
	}
}

public struct Beta: FlatBufferObject {

	static func validateVersion() { FlatBuffersVersion_1_12_0() }
	public var __buffer: ByteBuffer! { return _accessor.bb }

	private var _accessor: Table
	public static func finish(_ fbb: FlatBufferBuilder, end: Offset<UOffset>, prefix: Bool = false) { fbb.finish(offset: end, fileId: "PPXF", addPrefix: prefix) }
	public static func getRootAsBeta(bb: ByteBuffer) -> Beta { return Beta(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public var concentration1: ppx.Tensor? { let o = _accessor.offset(4); return o == 0 ? nil : ppx.Tensor(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
	public var concentration0: ppx.Tensor? { let o = _accessor.offset(6); return o == 0 ? nil : ppx.Tensor(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
	public static func startBeta(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
	public static func add(concentration1: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: concentration1, at: 0)  }
	public static func add(concentration0: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: concentration0, at: 1)  }
	public static func endBeta(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
	public static func createBeta(_ fbb: FlatBufferBuilder,
		offsetOfConcentration1 concentration1: Offset<UOffset> = Offset(),
		offsetOfConcentration0 concentration0: Offset<UOffset> = Offset()) -> Offset<UOffset> {
		let __start = Beta.startBeta(fbb)
		Beta.add(concentration1: concentration1, fbb)
		Beta.add(concentration0: concentration0, fbb)
		return Beta.endBeta(fbb, start: __start)
	}
}

public struct Exponential: FlatBufferObject {

	static func validateVersion() { FlatBuffersVersion_1_12_0() }
	public var __buffer: ByteBuffer! { return _accessor.bb }

	private var _accessor: Table
	public static func finish(_ fbb: FlatBufferBuilder, end: Offset<UOffset>, prefix: Bool = false) { fbb.finish(offset: end, fileId: "PPXF", addPrefix: prefix) }
	public static func getRootAsExponential(bb: ByteBuffer) -> Exponential { return Exponential(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public var rate: ppx.Tensor? { let o = _accessor.offset(4); return o == 0 ? nil : ppx.Tensor(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
	public static func startExponential(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
	public static func add(rate: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: rate, at: 0)  }
	public static func endExponential(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
	public static func createExponential(_ fbb: FlatBufferBuilder,
		offsetOfRate rate: Offset<UOffset> = Offset()) -> Offset<UOffset> {
		let __start = Exponential.startExponential(fbb)
		Exponential.add(rate: rate, fbb)
		return Exponential.endExponential(fbb, start: __start)
	}
}

public struct Gamma: FlatBufferObject {

	static func validateVersion() { FlatBuffersVersion_1_12_0() }
	public var __buffer: ByteBuffer! { return _accessor.bb }

	private var _accessor: Table
	public static func finish(_ fbb: FlatBufferBuilder, end: Offset<UOffset>, prefix: Bool = false) { fbb.finish(offset: end, fileId: "PPXF", addPrefix: prefix) }
	public static func getRootAsGamma(bb: ByteBuffer) -> Gamma { return Gamma(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public var concentration: ppx.Tensor? { let o = _accessor.offset(4); return o == 0 ? nil : ppx.Tensor(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
	public var rate: ppx.Tensor? { let o = _accessor.offset(6); return o == 0 ? nil : ppx.Tensor(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
	public static func startGamma(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
	public static func add(concentration: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: concentration, at: 0)  }
	public static func add(rate: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: rate, at: 1)  }
	public static func endGamma(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
	public static func createGamma(_ fbb: FlatBufferBuilder,
		offsetOfConcentration concentration: Offset<UOffset> = Offset(),
		offsetOfRate rate: Offset<UOffset> = Offset()) -> Offset<UOffset> {
		let __start = Gamma.startGamma(fbb)
		Gamma.add(concentration: concentration, fbb)
		Gamma.add(rate: rate, fbb)
		return Gamma.endGamma(fbb, start: __start)
	}
}

public struct LogNormal: FlatBufferObject {

	static func validateVersion() { FlatBuffersVersion_1_12_0() }
	public var __buffer: ByteBuffer! { return _accessor.bb }

	private var _accessor: Table
	public static func finish(_ fbb: FlatBufferBuilder, end: Offset<UOffset>, prefix: Bool = false) { fbb.finish(offset: end, fileId: "PPXF", addPrefix: prefix) }
	public static func getRootAsLogNormal(bb: ByteBuffer) -> LogNormal { return LogNormal(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public var loc: ppx.Tensor? { let o = _accessor.offset(4); return o == 0 ? nil : ppx.Tensor(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
	public var scale: ppx.Tensor? { let o = _accessor.offset(6); return o == 0 ? nil : ppx.Tensor(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
	public static func startLogNormal(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
	public static func add(loc: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: loc, at: 0)  }
	public static func add(scale: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: scale, at: 1)  }
	public static func endLogNormal(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
	public static func createLogNormal(_ fbb: FlatBufferBuilder,
		offsetOfLoc loc: Offset<UOffset> = Offset(),
		offsetOfScale scale: Offset<UOffset> = Offset()) -> Offset<UOffset> {
		let __start = LogNormal.startLogNormal(fbb)
		LogNormal.add(loc: loc, fbb)
		LogNormal.add(scale: scale, fbb)
		return LogNormal.endLogNormal(fbb, start: __start)
	}
}

}

// MARK: - ppx


